else if(any(transform == "log")){
markers <- log(markers)
}
else if(any(transform == "exp")){
markers <- exp(markers)
}
else if(any(transform == "sin")){
markers <- sin(markers)
}
else {
markers <- cos(markers)
}
x <- as.matrix(seq(-3, 3, 0.1))
n <- seq(1:nrow(x))
get_roc <- function(n){
values <- suppressMessages(pROC::roc(status , power[,n], direction = direction))
auc <- values$auc
return(auc)
}
if (method == "add"){
if(power.transform == TRUE){
power <- apply(x, 1, power.add)
auc_list <- sapply(n, get_roc)
max_index <- which(auc_list == max(auc_list))
if(length(max_index)>1){
max_index <- max_index[1]
}
comb.score <- power[,max_index]
}
else {comb.score <- markers[ ,1] + markers[ ,2]}
} else if (method == "multiply") {
comb.score <- markers[ ,1] * markers[ ,2]
} else if (method == "divide"){
comb.score <- markers[ ,1] / markers[ ,2]
} else if (method == "subtract"){
if(power.transform == TRUE){
power <- apply(x, 1, power.subt)
auc_list <- sapply(n, get_roc)
max_index <- which(auc_list == max(auc_list))
if(length(max_index)>1){
max_index <- max_index[1]
}
comb.score <- power[,max_index]
}
else{comb.score <- (markers[ ,1] - markers[ ,2])}
}  else if(method == "distance"){
distMethod <- function(params){
origin <-c(0,0)
suppressMessages(philentropy::distance(rbind(origin, params),
method = distance,
use.row.names = TRUE))
}
comb.score <- as.matrix(unlist(apply(markers, 1, distMethod)))
rownames(comb.score) <- NULL
} else if (method == "first^sec") {
comb.score <- markers[ ,1] ^ markers[ ,2]
} else if (method == "sec^first") {
comb.score <- markers[ ,2] ^ markers[ ,1]
}
comb.score <- as.matrix(comb.score)
allres <- rocsum(markers = markers, comb.score = comb.score, status = status,
event = event, direction = direction, conf.level = conf.level,
cutoff.method = cutoff.method)
return(allres)
}
power.add <- function(x){
power1 <- markers[,1] ^ x
power2 <- markers[,2] ^ x
return (power1 + power2)
}
power.subt <- function(x){
power1 <- markers[,1] ^ x
power2 <- markers[,2] ^ x
return (power1 - power2)
}
data(exampleData1)
markers <- exampleData1[, -1]
status <- factor(exampleData1$group, levels = c("not_needed", "needed"))
event <- "needed"
direction <- "<"
cutoff.method <- "youden"
score2 <- mathComb(markers = markers, status = status, event = event,
method = "sec^first", transform = "exp", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "expinbase", transform = "exp", direction = direction, cutoff.method = cutoff.method)
mathComb <- function(markers = NULL, status = NULL, event = NULL,
method = c("add", "multiply", "divide", "subtract",
"distance", "baseinexp", "expinbase"),
distance = c("euclidean", "manhattan", "chebyshev",
"kulczynski_d", "lorentzian", "taneja",
"kumar-johnson", "avg"),
standardize = c("none", "range",
"zScore", "tScore", "mean", "deviance"),
transform = c("none", "log", "exp",
"sin", "cos"),
power.transform = FALSE, direction = c("<", ">"),
conf.level = 0.95, cutoff.method = c("youden", "roc01")){
match.arg(method)
match.arg(distance)
match.arg(transform)
match.arg(direction)
match.arg(cutoff.method)
if (!is.data.frame(markers)) {
markers <- as.data.frame(markers)
}
for(i in 1:ncol(markers)) if(!is.numeric(markers[, i]))
stop("at least one variable is not numeric")
if(!ncol(markers) == 2)
stop("the number of markers should be 2")
if(!is.factor(status)) status <- as.factor(status)
if(!length(levels(status)) == 2)
stop("the number of status levels should be 2")
stopifnot(event %in% status)
levels(status)[levels(status) == "NA"] <- NA
stopifnot(nrow(markers) == length(status))
status <- factor(ifelse(status == event, 1, 0))
comp <- complete.cases(markers)
markers <- markers[comp, ]
status <- status[comp]
if (is.null(standardize)){
standardize <- "none"
}
if(any(standardize == "none")){
markers <- markers
}
else if (any(standardize == "range")){
markers <- std.range(markers)
}
else if (any(standardize == "zScore")){
markers <- std.zscore(markers)
}
else if (any(standardize == "tScore")){
markers <- std.tscore(markers)
}
else if (any(standardize == "mean")){
markers <- std.mean(markers)
}
else if (any(standardize == "deviance")){
markers <- std.deviance(markers)
}
if (is.null(transform)){
transform <- "none"
}
if(any(transform == "none")){
markers <- markers
}
else if(any(transform == "log")){
markers <- log(markers)
}
else if(any(transform == "exp")){
markers <- exp(markers)
}
else if(any(transform == "sin")){
markers <- sin(markers)
}
else {
markers <- cos(markers)
}
x <- as.matrix(seq(-3, 3, 0.1))
n <- seq(1:nrow(x))
get_roc <- function(n){
values <- suppressMessages(pROC::roc(status , power[,n], direction = direction))
auc <- values$auc
return(auc)
}
if (method == "add"){
if(power.transform == TRUE){
power <- apply(x, 1, power.add)
auc_list <- sapply(n, get_roc)
max_index <- which(auc_list == max(auc_list))
if(length(max_index)>1){
max_index <- max_index[1]
}
comb.score <- power[,max_index]
}
else {comb.score <- markers[ ,1] + markers[ ,2]}
} else if (method == "multiply") {
comb.score <- markers[ ,1] * markers[ ,2]
} else if (method == "divide"){
comb.score <- markers[ ,1] / markers[ ,2]
} else if (method == "subtract"){
if(power.transform == TRUE){
power <- apply(x, 1, power.subt)
auc_list <- sapply(n, get_roc)
max_index <- which(auc_list == max(auc_list))
if(length(max_index)>1){
max_index <- max_index[1]
}
comb.score <- power[,max_index]
}
else{comb.score <- (markers[ ,1] - markers[ ,2])}
}  else if(method == "distance"){
distMethod <- function(params){
origin <-c(0,0)
suppressMessages(philentropy::distance(rbind(origin, params),
method = distance,
use.row.names = TRUE))
}
comb.score <- as.matrix(unlist(apply(markers, 1, distMethod)))
rownames(comb.score) <- NULL
} else if (method == "baseinexp") {
comb.score <- markers[ ,1] ^ markers[ ,2]
} else if (method == "expinbase") {
comb.score <- markers[ ,2] ^ markers[ ,1]
}
comb.score <- as.matrix(comb.score)
allres <- rocsum(markers = markers, comb.score = comb.score, status = status,
event = event, direction = direction, conf.level = conf.level,
cutoff.method = cutoff.method)
return(allres)
}
score2 <- mathComb(markers = markers, status = status, event = event,
method = "expinbase", transform = "exp", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "expinbase", transform = "log", direction = direction, cutoff.method = cutoff.method)
a <- exp(markers)
head(a)
a[,1]
a[,2]
a[,1] ^a[,2]
score2 <- mathComb(markers = markers, status = status, event = event,
method = "expinbase", transform = "log", standardize= "range", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "expinbase", standardize= "range", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "baseinexp", standardize= "range", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "baseinexp", standardize= "zScore", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "baseinexp", standardize= "mean", direction = direction, cutoff.method = cutoff.method)
linComb <- function(markers = NULL, status = NULL, event = NULL,
method = c("scoring", "SL", "logistic", "minmax",
"PT", "PCL", "minimax", "TS"),
standardize = c("none", "range",
"zScore", "tScore", "mean", "deviance"),
ndigits = 0, init.param = 0.01,
direction = c("<", ">"), conf.level = 0.95,
cutoff.method = c("youden", "roc01")){
match.arg(method)
match.arg(direction)
match.arg(cutoff.method)
if (!is.data.frame(markers)) {
markers <- as.data.frame(markers)
}
for(i in 1:ncol(markers)) if(!is.numeric(markers[, i]))
stop("at least one variable is not numeric")
if(!ncol(markers) == 2)
stop("the number of markers should be 2")
if(!is.factor(status)) status <- as.factor(status)
if(!length(levels(status)) == 2)
stop("the number of status levels should be 2")
stopifnot(event %in% status)
levels(status)[levels(status) == "NA"] <- NA
stopifnot(nrow(markers) == length(status))
status <- factor(ifelse(status == event, 1, 0))
comp <- complete.cases(markers)
markers <- markers[comp, ]
status <- status[comp]
if (is.null(standardize)){
standardize <- "none"
}
if (method %in% c("minmax", "PT", "PCL") && (!standardize == "range")){
warning("The used combination method requires range standardization.
All biomarker values are standardized to a range between 0 and 1.")
standardize <- "range"
}
if(any(standardize == "none")){
markers <- markers
}
else if (any(standardize == "range")){
markers <- std.range(markers)
}
else if (any(standardize == "zScore")){
markers <- std.zscore(markers)
}
else if (any(standardize == "tScore")){
markers <- std.tscore(markers)
}
else if (any(standardize == "mean")){
markers <- std.mean(markers)
}
else if (any(standardize == "deviance")){
markers <- std.deviance(markers)
}
neg.markers <- markers[status != 1, ]
pos.markers <- markers[status == 1, ]
if (method == "scoring"){
res <- glm(status ~ markers[ , 1] + markers[ , 2],
family = binomial((link = "logit")))
round.coef <- abs(round(res$coefficients, digits = ndigits))
comb.score <- as.matrix(markers) %*% as.matrix(round.coef[-1])
} else if (method == "SL" ) {
sum.var <- var(pos.markers) + var(neg.markers)
subs_mean <- colMeans(pos.markers) - colMeans(neg.markers)
est.coef <- as.numeric(abs(solve(sum.var) %*% subs_mean))
comb.score <- as.matrix(markers) %*% est.coef
} else if (method == "logistic"){
res <- glm(status ~ markers[ , 1] + markers[ , 2],
family = binomial((link = "logit")))
comb.score <- as.matrix(predict(res, newdata = markers, type = "response"))
} else if (method == "minmax"){
opt.func <- optim(par = init.param, fn = helper_minmax, neg.set = neg.markers,
pos.set = pos.markers, method = "Brent",
lower = 0, upper = 1)
lambda <- as.numeric(opt.func$par)
comb.score <- as.matrix(apply(markers, 1, max)
+ lambda * apply(markers, 1, min))
} else if(method == "PT"){
markers <- as.matrix(markers)
model <- glm(status ~ markers, family = binomial(link = "logit"))
lambda <- model$coefficients[3] / model$coefficients[2]
comb.score <- as.matrix(markers[, 1] + lambda * markers[, 2])
} else if(method == "PCL"){
opt.func <- optim(par = init.param, fn = helper_PCL,
neg.set = neg.markers , pos.set = pos.markers,
method = "Brent", lower = 0, upper = 1)
lambda <- as.numeric(opt.func$par)
markers <- as.matrix(markers)
comb.score <-  as.matrix(markers[ ,1] + markers[ ,2] * lambda)
} else if(method == "minimax"){
opt.func <- optim(par = init.param, fn = helper_minimax,
neg.set = neg.markers , pos.set = pos.markers,
marker.set = markers, status = status,
method = "Brent", lower = 0, upper = 1)
t <- as.numeric(opt.func$par)
b.coef <- (solve(t * var(pos.markers)) + (1 - t) * var(neg.markers)) %*%
(colMeans(pos.markers) - colMeans(neg.markers))
comb.score <- as.matrix(markers) %*% b.coef
} else if(method == "TS"){
opt.func <- optim(par = init.param, fn = helper_TS, marker.set = markers,
status = status, method = "Brent",
lower = -1.57079633, upper = 1.57079633)
theta <- as.numeric(opt.func$par)
a1 <- sin(theta)
a2 <- cos(theta)
comb.score <- as.matrix(a1 * markers[, 1] + a2 * markers[, 2])
}
allres <- rocsum(markers = markers, comb.score = comb.score, status = status,
event = event, direction = direction, conf.level = conf.level,
cutoff.method = cutoff.method)
return(allres)
}
helper_minmax <- function(lambda, neg.set, pos.set){
Xmax <- as.matrix(apply(neg.set, 1, max))
Xmin <- as.matrix(apply(neg.set, 1, min))
Ymax <- as.matrix(apply(pos.set, 1, max))
Ymin <- as.matrix(apply(pos.set, 1, min))
W.lambda <- 0
n <- dim(neg.set)[1]
m <- dim(pos.set)[1]
for (i in 1:n){
for(j in 1:m){
W.lambda <- W.lambda + as.numeric(Ymax[j, ] + lambda * Ymin[j, ] >
Xmax[i, ] + lambda * Xmin[i, ])
}
}
return(-W.lambda / (n * m))
}
#' @title Mann Whitney AUC estimator for PCL method.
#'
#' @description The \code{helper_PCL} function estimates non-parametric
#' AUC for the given biomarkers
#'
#' @param lambda a \code{numeric} parameter that will be estimated in minmax
#' method for the combination score
#'
#' @param neg.set a \code{numeric} data frame that contains the observation with
#' negative status
#'
#' @param pos.set a \code{numeric} data frame that contains the observation with
#' positive status
#'
#' @return A \code{numeric} value for the estimated AUC
#'
#' @author Serra Bersan Gengec, Ilayda Serra Yerlitas
#'
#' @examples
#' #call data
#' data(exampleData1)
#'
#' #define the function parameters
#' markers <- cbind(exampleData1$ddimer, exampleData1$log_leukocyte)
#' status <- factor(exampleData1$group, levels = c("not_needed", "needed"))
#'
#' neg.set <- markers[status == levels(status)[1], ]
#' pos.set <- markers[status == levels(status)[2], ]
#'
#' lambda = 0.5
#'
#' stat <- helper_PCL(lambda, neg.set = neg.set, pos.set = pos.set)
#'
#' @export
helper_PCL <- function(lambda, neg.set, pos.set){
YD1 <- as.matrix(pos.set[ , 1])
YD2 <- as.matrix(pos.set[ , 2])
YDN1 <- as.matrix(neg.set[ , 1])
YDN2 <- as.matrix(neg.set[ , 2])
W.lambda <- 0
n <- dim(pos.set)[1]
m <- dim(neg.set)[1]
for (i in 1:n){
for(j in 1:m){
W.lambda <- W.lambda +
as.numeric(YD1[i, ] + lambda * YD2[i, ] >
YDN1[j, ] + lambda * YDN2[j, ])+
as.numeric(YD1[i, ] + lambda * YD2[i, ] == YDN1[j, ] +
lambda * YDN2[j, ])/2
}
}
return(-W.lambda / (n * m))
}
#' @title AUC calculator for minimax method.
#'
#' @description The \code{helper_minimax} function calculates the combination
#' coefficient and AUC value of given biomarkers for minimax method
#'
#' @param t a \code{numeric} parameter that will be estimated in minimax
#' method for the combination score
#'
#' @param neg.set a \code{numeric} data frame that contains the observation with
#' negative status
#'
#' @param pos.set a \code{numeric} data frame that contains the observation with
#' positive status
#'
#' @param marker.set a \code{numeric} data frame that contains the biomarkers
#'
#' @param status a \code{factor} data frame that includes the actual disease
#' status of the patients
#'
#' @return A \code{numeric} AUC value calculated with combination scores using t
#'
#' @author Serra Bersan Gengec, Ilayda Serra Yerlitas
#'
#' @examples
#' #call data
#' data(exampleData1)
#'
#' #define the function parameters
#' markers <- cbind(exampleData1$ddimer, exampleData1$log_leukocyte)
#' status <- factor(exampleData1$group, levels = c("not_needed", "needed"))
#'
#' neg.set <- markers[status == levels(status)[1], ]
#' pos.set <- markers[status == levels(status)[2], ]
#'
#' t <- 0.5
#'
#' stat <- helper_minimax(t, neg.set = neg.set, pos.set = pos.set,
#' marker.set = markers, status)
#'
#' @importFrom pROC auc
#'
#' @export
helper_minimax <- function(t, neg.set, pos.set, markers, status){
b.coef <- (solve(t * var(pos.set)) + (1 - t) * var(neg.set)) %*%
(colMeans(pos.set) - colMeans(neg.set))
comb.score <- as.matrix(markers) %*% b.coef
comb.score <- as.numeric(comb.score)
auc_value <- suppressMessages(as.numeric(pROC::auc(status, comb.score)))
return(-(auc_value))
}
#' @title AUC calculator for TS method.
#'
#' @description The \code{helper_TS} function calculates the combination
#'   coefficient and AUC value of given biomarkers for the TS method
#'
#' @param theta a \code{numeric} parameter that will be estimated in the TS
#'   method for the combination score
#'
#' @param marker.set a \code{numeric} data frame that contains the biomarkers
#'
#' @param status a \code{factor} data frame that includes the actual disease
#'   status of the patients
#'
#' @return A \code{numeric} AUC value calculated with combination scores using
#'   trigonometric functions of theta
#'
#' @author Serra Bersan Gengec, Ilayda Serra Yerlitas
#'
#' @examples
#' #call data
#' data(exampleData1)
#'
#' #define the function parameters
#' markers <- cbind(exampleData1$ddimer, exampleData1$log_leukocyte)
#' status <- factor(exampleData1$group, levels = c("not_needed", "needed"))
#'
#' theta <- 0.08
#'
#' stat <- helper_TS(theta = theta, markers = markers, status = status)
#'
#' @importFrom pROC auc
#'
#' @export
helper_TS <- function(theta, markers, status){
a1 <- sin(theta)
a2 <- cos(theta)
z <- a1 * marker.set[, 1] + a2 * markers[, 2]
roc_obj <- suppressMessages(pROC::roc(status, z))
auc_value <- as.numeric(pROC::auc(roc_obj))
return(-(auc_value))
}
score1 <- linComb(markers = markers, status = status, event = event,
method = "scoring", ndigits = 0, standardize = "zscore", , direction = "<",
cutoff.method = "youden")
score1 <- linComb(markers = markers, status = status, event = event,
method = "scoring", ndigits = 0, standardize = "zscore", , direction = "<",
cutoff.method = "youden")
score2 <- mathComb(markers = markers, status = status, event = event,
method = "baseinexp", standardize= "deviance", direction = direction, cutoff.method = cutoff.method)
score2 <- mathComb(markers = markers, status = status, event = event,
method = "baseinexp", standardize= "tScore", direction = direction, cutoff.method = cutoff.method)
